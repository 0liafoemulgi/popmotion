'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

var Action = require('./Action'),
    calc = require('../inc/calc'),
    STRING = 'string',

/*
    Translate our mapLink value into mapTo
    
    @param [number]: Calculated value from linked value
    @param [Value || object]: Linked value or empty object if we're linking to input
    @param [array]: List of numbers relating to linked value
    @param [array]: List of numbers relating to this value
*/
findMappedValue = function (newValue, linkedValue, toValue, mapLink, mapTo) {
    var mapLength = mapLink.length,
        i = 1,
        lastLinkValue,
        thisLinkValue,
        lastToValue,
        thisToValue;

    for (; i < mapLength; i++) {
        // Assign values from array, or if they're strings, look for them in linkedValue
        lastLinkValue = _typeof(mapLink[i - 1]) === STRING ? linkedValue[mapLink[i - 1]] : mapLink[i - 1];
        thisLinkValue = _typeof(mapLink[i]) === STRING ? linkedValue[mapLink[i]] : mapLink[i];
        lastToValue = _typeof(mapTo[i - 1]) === STRING ? toValue[mapTo[i - 1]] : mapTo[i - 1];
        thisToValue = _typeof(mapTo[i]) === STRING ? toValue[mapTo[i]] : mapTo[i];

        // Check if we've gone past our calculated value, or if we're at the end of the array
        if (newValue < thisLinkValue || i === mapLength - 1) {
            newValue = calc.value(calc.restricted(calc.progress(newValue, lastLinkValue, thisLinkValue), 0, 1), lastToValue, thisToValue);
            break;
        }
    }

    return newValue;
};

var Watch = (function (_Action) {
    _inherits(Watch, _Action);

    function Watch() {
        _classCallCheck(this, Watch);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, _Action.call.apply(_Action, [this].concat(args)));

        _this.isActive = true;
        return _this;
    }

    /*
        Process this value
        
        First check if this value exists as a Value, if not
        check within Input (if we have one)
            
        @param [Actor]
        @param [Value]: Current value
        @param [string]: Key of current value
        @return [number]: Calculated value
    */

    Watch.prototype.process = function process(actor, value, key) {
        var values = actor.values,
            newValue = value.current,
            watchedKey = value.watch,
            watchedValue = values[watchedKey] ? values[watchedKey] : {},
            inputOffset = value.action ? value.action.inputOffset : false;

        // First look at Action and check value isn't linking itself
        if (watchedValue.current !== undefined && key !== watchedKey) {
            newValue = watchedValue.current;

            // Then check values in Input
        } else if (inputOffset && inputOffset.hasOwnProperty(watchedKey)) {
                newValue = value.action.process(actor, value, watchedKey);
            }

        // If we have mapFrom and mapTo properties, translate the new value
        if (value.mapFrom && value.mapTo) {
            value.unmapped = newValue;
            newValue = findMappedValue(newValue, watchedValue, value, value.mapFrom, value.mapTo);
        }

        return newValue;
    };

    return Watch;
})(Action);

module.exports = Watch;